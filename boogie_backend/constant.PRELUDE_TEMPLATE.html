<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="API documentation for the Rust `PRELUDE_TEMPLATE` constant in crate `boogie_backend`."><meta name="keywords" content="rust, rustlang, rust-lang, PRELUDE_TEMPLATE"><title>boogie_backend::PRELUDE_TEMPLATE - Rust</title><link rel="stylesheet" type="text/css" href="../normalize.css"><link rel="stylesheet" type="text/css" href="../rustdoc.css" id="mainThemeStyle"><link rel="stylesheet" type="text/css" href="../light.css"  id="themeStyle"><link rel="stylesheet" type="text/css" href="../dark.css" disabled ><link rel="stylesheet" type="text/css" href="../ayu.css" disabled ><script id="default-settings"></script><script src="../storage.js"></script><noscript><link rel="stylesheet" href="../noscript.css"></noscript><link rel="icon" type="image/svg+xml" href="../favicon.svg">
<link rel="alternate icon" type="image/png" href="../favicon-16x16.png">
<link rel="alternate icon" type="image/png" href="../favicon-32x32.png"><style type="text/css">#crate-search{background-image:url("../down-arrow.svg");}</style></head><body class="rustdoc constant"><!--[if lte IE 8]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="sidebar"><div class="sidebar-menu">&#9776;</div><a href='../boogie_backend/index.html'><div class='logo-container rust-logo'><img src='../rust-logo.png' alt='logo'></div></a><div class="sidebar-elems"><p class="location"><a href="index.html">boogie_backend</a></p><div id="sidebar-vars" data-name="PRELUDE_TEMPLATE" data-ty="constant" data-relpath=""></div><script defer src="sidebar-items.js"></script></div></nav><div class="theme-picker"><button id="theme-picker" aria-label="Pick another theme!" aria-haspopup="menu"><img src="../brush.svg" width="18" alt="Pick another theme!"></button><div id="theme-choices" role="menu"></div></div><script src="../theme.js"></script><nav class="sub"><form class="search-form"><div class="search-container"><div><select id="crate-search"><option value="All crates">All crates</option></select><input class="search-input" name="search" disabled autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"></div><button type="button" class="help-button">?</button>
                <a id="settings-menu" href="../settings.html"><img src="../wheel.svg" width="18" alt="Change settings"></a></div></form></nav><section id="main" class="content"><h1 class="fqn"><span class="in-band">Constant <a href="index.html">boogie_backend</a>::<wbr><a class="constant" href="">PRELUDE_TEMPLATE</a></span><span class="out-of-band"><span id="render-detail"><a id="toggle-all-docs" href="javascript:void(0)" title="collapse all docs">[<span class="inner">&#x2212;</span>]</a></span><a class="srclink" href="../src/boogie_backend/lib.rs.html#16" title="goto source code">[src]</a></span></h1><pre class="rust const">pub const PRELUDE_TEMPLATE: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.slice.html">&amp;[</a><a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u8.html">u8</a><a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.slice.html">]</a> = b&quot;// ================================================================================\n// Notation\n\n// This files contains a Handlebars Rust template for the prover\&#39;s Boogie prelude.\n// The template language constructs allow the prelude to adjust the actual content\n// to multiple options. We only use a few selected template constructs which are\n// mostly self-explaining. See the handlebars crate documentation for more information.\n//\n// The object passed in as context for templates is the struct `crate::TemplateOptions` and\n// which contains a field `options` which points `crate::options::Options`, that is the\n// backend command line options.\n\n// ================================================================================\n// Included theories\n\n// Which theory implementation is bound to these includes is determined\n// by the function `crate::add_prelude`, based on options provided to the prover.\n\n{{&gt; vector-theory }}\n{{&gt; multiset-theory }}\n\n\n// ============================================================================================\n// Type Values\n\ntype $TypeName;\ntype $FieldName = int;\ntype $LocalName;\ntype {:datatype} $TypeValue;\nfunction {:constructor} $BooleanType() : $TypeValue;\nfunction {:constructor} $IntegerType() : $TypeValue;\nfunction {:constructor} $AddressType() : $TypeValue;\nfunction {:constructor} $StrType() : $TypeValue;\nfunction {:constructor} $VectorType(t: $TypeValue) : $TypeValue;\nfunction {:constructor} $StructType(name: $TypeName, ts: Vec $TypeValue) : $TypeValue;\nfunction {:constructor} $TypeType(): $TypeValue;\nfunction {:constructor} $ErrorType() : $TypeValue;\n\n\n// ============================================================================================\n// Values\n\ntype {:datatype} $Value;\n\nconst $MAX_U8: int;\naxiom $MAX_U8 == 255;\nconst $MAX_U64: int;\naxiom $MAX_U64 == 18446744073709551615;\nconst $MAX_U128: int;\naxiom $MAX_U128 == 340282366920938463463374607431768211455;\n\nfunction {:constructor} $Boolean(b: bool): $Value;\nfunction {:constructor} $Integer(i: int): $Value;\nfunction {:constructor} $Address(a: int): $Value;\nfunction {:constructor} $Vector(v: Vec $Value): $Value; // used to both represent Move Struct and Vector\nfunction {:constructor} $Range(lb: int, ub: int): $Value;\nfunction {:constructor} $Type(t: $TypeValue): $Value;\nfunction {:constructor} $Error(): $Value;\n\nfunction {:inline} $DefaultValue(): $Value { $Error() }\n\nfunction {:inline} $IsValidBox(v: $Value): bool {\n    true\n}\n\nfunction {:inline} $IsValidBox_int(v: $Value): bool {\n  is#$Integer(v)\n}\n\nfunction {:inline} $IsValidBox_bool(v: $Value): bool {\n  is#$Boolean(v)\n}\n\nfunction {:inline} $IsValidBox_addr(v: $Value): bool {\n  is#$Address(v)\n}\n\nfunction {:inline} $IsValidBox_vec(v: $Value): bool {\n  is#$Vector(v)\n}\n\nfunction {:inline} $IsValidU8Boxed(v: $Value): bool {\n  $IsValidBox_int(v) &amp;&amp; $IsValidU8($Unbox_int(v))\n}\n\nfunction {:inline} $IsValidBool(v: bool): bool {\n  true\n}\n\nfunction {:inline} $IsValidU8(v: int): bool {\n  $TagU8(v) &amp;&amp; v &gt;= 0 &amp;&amp; v &lt;= $MAX_U8\n}\n\nfunction {:inline} $IsValidU8Vector(v: Vec $Value): bool {\n  $Vector_$is_well_formed($IntegerType(), v) &amp;&amp;\n  (forall i: int :: {ReadVec(v, i)} 0 &lt;= i &amp;&amp; i &lt; LenVec(v) ==&gt; $IsValidU8Boxed(ReadVec(v, i)))\n}\n\nfunction {:inline} $IsValidU64(v: int): bool {\n  $TagU64(v) &amp;&amp; v &gt;= 0 &amp;&amp; v &lt;= $MAX_U64\n}\n\nfunction {:inline} $IsValidU128(v: int): bool {\n  $TagU128(v) &amp;&amp; v &gt;= 0 &amp;&amp; v &lt;= $MAX_U128\n}\n\nfunction {:inline} $IsValidNum(v: int): bool {\n  $TagNum(v) &amp;&amp; true\n}\n\nfunction {:inline} $IsValidAddress(v: int): bool {\n  // TODO: restrict max to representable addresses?\n  $TagAddr(v) &amp;&amp; v &gt;= 0\n}\n\n// Non-inlined type tagging functions. Those are added to type assumptions to provide\n// a trigger for quantifier instantiation based on type information.\nfunction $TagBool(x: bool): bool { true }\nfunction $TagU8(x: int): bool { true }\nfunction $TagU64(x: int): bool { true }\nfunction $TagU128(x: int): bool { true }\nfunction $TagNum(x: int): bool { true }\nfunction $TagAddr(x: int): bool { true }\nfunction $TagType(x: $TypeValue): bool { true }\nfunction $TagVec(et: $TypeValue, x: Vec $Value): bool { true }\n\n\nfunction {:inline} $IsValidRange(r: $Value): bool {\n   $IsValidU64(lb#$Range(r)) &amp;&amp;  $IsValidU64(ub#$Range(r))\n}\n\nfunction {:inline} $InRange(r: $Value, i: int): bool {\n   lb#$Range(r) &lt;= i &amp;&amp; i &lt; ub#$Range(r)\n}\n\n// Canonical API to constructors/selectors, supporting codegen.\n\nfunction {:inline} $Box(x: $Value): $Value {\n    x\n}\nfunction {:inline} $Box_int(x: int): $Value {\n    $Integer(x)\n}\nfunction {:inline} $Box_bool(x: bool): $Value {\n    $Boolean(x)\n}\nfunction {:inline} $Box_addr(x: int): $Value {\n    $Address(x)\n}\nfunction {:inline} $Box_vec(x: Vec $Value): $Value {\n    $Vector(x)\n}\n\nfunction {:inline} $Unbox(x: $Value): $Value {\n    x\n}\nfunction {:inline} $Unbox_int(x: $Value): int {\n    i#$Integer(x)\n}\nfunction {:inline} $Unbox_bool(x: $Value): bool {\n    b#$Boolean(x)\n}\nfunction {:inline} $Unbox_addr(x: $Value): int {\n    a#$Address(x)\n}\nfunction {:inline} $Unbox_vec(x: $Value): Vec $Value {\n    v#$Vector(x)\n}\n\n// ============================================================================================\n// Helpers for Vectors\n\nfunction {:inline} $SliceVecByRange(v: Vec $Value, r: $Value): Vec $Value {\n    SliceVec(v, lb#$Range(r), ub#$Range(r))\n}\n\n{{#if options.native_equality}}\n\nfunction {:inline} $ContainsVec(v: Vec $Value, e: $Value): bool {\n    ContainsVec(v, e)\n}\n\nfunction {:inline} $IndexOfVec(v: Vec $Value, e: $Value): int {\n    IndexOfVec(v, e)\n}\n\n{{else}}\n\n// Because the vector implementation does not support extensional equality,\n// we need to redefine some functions here using $IsEqual.\n\nfunction {:inline} $ContainsVec(v: Vec $Value, e: $Value): bool {\n    (exists i: int :: $InRangeVec(v, i) &amp;&amp; $IsEqual(ReadVec(v, i), e))\n}\n\nfunction $IndexOfVec(v: Vec $Value, e: $Value): int;\naxiom (forall v: Vec $Value, e: $Value:: {$IndexOfVec(v, e)}\n    (var i := $IndexOfVec(v,e);\n     if (!$ContainsVec(v, e)) then i == -1\n     else $InRangeVec(v, i) &amp;&amp; $IsEqual(ReadVec(v, i), e) &amp;&amp;\n        (forall j: int :: j &gt;= 0 &amp;&amp; j &lt; i ==&gt; !$IsEqual(ReadVec(v, j), e))));\n\n{{/if}}\n\n// Specialize function InRangeVec. Currently there is no difference to the one\n// provided by the vectory theory, but we may want to refine this for triggering.\nfunction {:inline} $InRangeVec(v: Vec $Value, i: int): bool {\n    InRangeVec(v, i)\n}\n\n// ================================================================================\n// Path type\n\ntype {:datatype} $Path;\nfunction {:constructor} $Path(p: [int]int, size: int): $Path;\nconst $EmptyPath: $Path;\naxiom size#$Path($EmptyPath) == 0;\n\nfunction {:inline} $path_index_at(p: $Path, i: int): int {\n    p#$Path(p)[i]\n}\n\nconst $StratificationDepth: int;\naxiom $StratificationDepth == {{options.stratification_depth}};\n\n\n// Generate stratified $UpdateValue for the depth of {{options.stratification_depth}}.\n\n{{#stratified}}\nfunction {{options.aggressive_func_inline}} $UpdateValue_{{@this_suffix}}(p: $Path, offset: int, v: $Value, new_v: $Value): $Value {\n    (var poffset := offset + {{@this_level}};\n    if (poffset == size#$Path(p)) then\n        new_v\n    else\n        (var va := $Unbox_vec(v);\n         $Box_vec(UpdateVec(va, $path_index_at(p, poffset),\n                       $UpdateValue_{{@next_suffix}}(p, offset, ReadVec(va, $path_index_at(p, poffset)), new_v)))))\n}\n{{else}}\nfunction {:inline} $UpdateValue_{{@this_suffix}}(p: $Path, offset: int, v: $Value, new_v: $Value): $Value {\n    new_v\n}\n{{/stratified}}\n\nfunction {:inline} $UpdateValue(p: $Path, offset: int, v: $Value, new_v: $Value): $Value {\n    $UpdateValue_stratified(p, offset, v, new_v)\n}\n\n// Generate stratified $IsPathPrefix for the depth of {{options.stratification_depth}}.\n\n{{#stratified}}\nfunction {{options.aggressive_func_inline}} $IsPathPrefix_{{@this_suffix}}(p1: $Path, p2: $Path): bool {\n    if ({{@this_level}} == size#$Path(p1)) then\n        true\n    else if (p#$Path(p1)[{{@this_level}}] == p#$Path(p2)[{{@this_level}}]) then\n        $IsPathPrefix_{{@next_suffix}}(p1, p2)\n    else\n        false\n}\n{{else}}\nfunction {:inline} $IsPathPrefix_{{@this_suffix}}(p1: $Path, p2: $Path): bool {\n    true\n}\n{{/stratified}}\n\nfunction {:inline} $IsPathPrefix(p1: $Path, p2: $Path): bool {\n    $IsPathPrefix_stratified(p1, p2)\n}\n\n// Generate stratified $ConcatPath for the depth of {{options.stratification_depth}}.\n\n{{#stratified}}\nfunction {{options.aggressive_func_inline}} $ConcatPath_{{@this_suffix}}(p1: $Path, p2: $Path): $Path {\n    if ({{@this_level}} == size#$Path(p2)) then\n        p1\n    else\n        $ConcatPath_{{@next_suffix}}($Path(p#$Path(p1)[size#$Path(p1) := p#$Path(p2)[{{@this_level}}]], size#$Path(p1) + 1), p2)\n}\n{{else}}\nfunction {:inline} $ConcatPath_{{@this_suffix}}(p1: $Path, p2: $Path): $Path {\n    p1\n}\n{{/stratified}}\n\nfunction {:inline} $ConcatPath(p1: $Path, p2: $Path): $Path {\n    $ConcatPath_stratified(p1, p2)\n}\n\n// ============================================================================================\n// Equality\n\n{{#if options.native_equality}}\n\n// Map IsEqual to native Boogie equality. This only works with vector theories with\n// extensional equality.\nfunction {:inline} $IsEqual(v1: $Value, v2: $Value): bool {\n    v1 == v2\n}\n\nfunction {:inline} $IsEqual_vec(x: Vec $Value, y: Vec $Value): bool {\n    x == y\n}\n\n{{else}}\n\n// Generate a stratified version of IsEqual for depth of {{options.stratification_depth}}.\n\n{{#stratified}}\nfunction {{options.aggressive_func_inline}} $IsEqual_{{@this_suffix}}(v1: $Value, v2: $Value): bool {\n    (v1 == v2) ||\n    (is#$Vector(v1) &amp;&amp;\n     is#$Vector(v2) &amp;&amp;\n     (var vec1, vec2 := $Unbox_vec(v1), $Unbox_vec(v2);\n      LenVec(vec1) == LenVec(vec2) &amp;&amp;\n      (forall i: int :: 0 &lt;= i &amp;&amp; i &lt; LenVec(vec1) ==&gt; $IsEqual_{{@next_suffix}}(ReadVec(vec1,i), ReadVec(vec2,i)))))\n}\n{{else}}\nfunction {:inline} $IsEqual_{{@this_suffix}}(v1: $Value, v2: $Value): bool {\n    v1 == v2\n}\n{{/stratified}}\n\nfunction {:inline} $IsEqual(v1: $Value, v2: $Value): bool {\n    $IsEqual_stratified(v1, v2)\n}\n\nfunction {:inline} $IsEqual_vec(v1: Vec $Value, v2: Vec $Value): bool {\n    v1 == v2 ||\n    (LenVec(v1) == LenVec(v2) &amp;&amp;\n     (forall i: int :: 0 &lt;= i &amp;&amp; i &lt; LenVec(v1) ==&gt; $IsEqual(ReadVec(v1, i), ReadVec(v2, i))))\n}\n\n{{/if}}\n\nfunction {:inline} $IsEqual_int(x: int, y: int): bool {\n    x == y\n}\n\nfunction {:inline} $IsEqual_addr(x: int, y: int): bool {\n    x == y\n}\n\nfunction {:inline} $IsEqual_bool(x: bool, y: bool): bool {\n    x == y\n}\n\nfunction {:inline} $IsEqual_type(x: $TypeValue, y: $TypeValue): bool {\n    x == y\n}\n\n\n\n\n// ============================================================================================\n// Memory\n\ntype {:datatype} $Location;\n\n// A global resource location within the statically known resource type\&#39;s memory.\n// `ts` are the type parameters for the outer type, and `a` is the address.\nfunction {:constructor} $Global(ts: Vec $TypeValue, a: int): $Location;\n\n// A local location. `i` is the unique index of the local.\nfunction {:constructor} $Local(i: int): $Location;\n\n// The location of a reference outside of the verification scope, for example, a `&amp;mut` parameter\n// of the function being verified. References with these locations don\&#39;t need to be written back\n// when mutation ends.\nfunction {:constructor} $Param(i: int): $Location;\n\n\n// A mutable reference which also carries its current value. Since mutable references\n// are single threaded in Move, we can keep them together and treat them as a value\n// during mutation until the point they are stored back to their original location.\ntype {:datatype} $Mutation;\nfunction {:constructor} $Mutation(l: $Location, p: $Path, v: $Value): $Mutation;\n\n// Representation of memory for a given type. The maps take the content of a Global location.\ntype {:datatype} $Memory;\nfunction {:constructor} $Memory(domain: [Vec $TypeValue, int]bool, contents: [Vec $TypeValue, int]Vec $Value): $Memory;\n\nfunction {:inline} $Memory__is_well_formed(m: $Memory): bool {\n    true\n}\n\nfunction {:builtin \&quot;MapConst\&quot;} $ConstMemoryDomain(v: bool): [Vec $TypeValue, int]bool;\nfunction {:builtin \&quot;MapConst\&quot;} $ConstMemoryContent(v: Vec $Value): [Vec $TypeValue, int]Vec $Value;\naxiom $ConstMemoryDomain(false) == (lambda ta: Vec $TypeValue, i: int :: false);\naxiom $ConstMemoryDomain(true) == (lambda ta: Vec $TypeValue, i: int :: true);\n\nconst $EmptyMemory: $Memory;\naxiom domain#$Memory($EmptyMemory) == $ConstMemoryDomain(false);\naxiom contents#$Memory($EmptyMemory) == $ConstMemoryContent(EmptyVec());\n\n// Returns a new memory which is identical than the given memory except at (type_args, addr) which\n// is arbitrary.\nprocedure {:inline 1} $Modifies(m: $Memory, type_args: Vec $TypeValue, addr: int) returns (m\&#39;: $Memory) {\n    m\&#39; := $Memory(\n        domain#$Memory(m)[type_args, addr := domain#$Memory(m\&#39;)[type_args, addr]],\n        contents#$Memory(m)[type_args, addr := contents#$Memory(m\&#39;)[type_args, addr]]\n    );\n}\n\n// Dereferences a mutation.\nfunction {:inline} $Dereference(ref: $Mutation): $Value {\n    v#$Mutation(ref)\n}\n\n// Update the value of a mutation.\nfunction {:inline} $UpdateMutation(m: $Mutation, v: $Value): $Mutation {\n    $Mutation(l#$Mutation(m), p#$Mutation(m), v)\n}\n\n// Havoc the value of a mutation.\nprocedure {:inline 1} $HavocMutation(m: $Mutation) returns (m\&#39;: $Mutation) {\n  var v\&#39;: $Value;\n  m\&#39; := $Mutation(l#$Mutation(m), p#$Mutation(m), v\&#39;);\n}\n\n// Tests whether resource exists.\nfunction {:inline} $ResourceExists(m: $Memory, args: Vec $TypeValue, addr: int): bool {\n    domain#$Memory(m)[args, addr]\n}\n\n// Obtains Value of given resource.\nfunction {:inline} $ResourceValue(m: $Memory, args: Vec $TypeValue, addr: int): Vec $Value {\n    contents#$Memory(m)[args, addr]\n}\n\n// ============================================================================================\n// EventStore\n\n{{#if options.native_equality}}\n\n// TODO: like to have this as aliases, but currently blocked by boogie issue #364\ntype {:datatype} $EventRep;\ntype {:datatype} $GuidRep;\nfunction {:constructor} $ToEventRep(event: $Value): $EventRep;\nfunction {:constructor} $ToGuidRep(guid: Vec $Value): $GuidRep;\n\n{{else}}\n\n// Because we do not have extensional equality we need to encode events and guids\n// in abstract types which have equality, so they can be used as indices for Boogie arrays.\n\ntype $EventRep;\ntype $GuidRep;\n\nfunction $ToEventRep(event: $Value): $EventRep;\nfunction $ToGuidRep(guid: Vec $Value): $GuidRep;\n\naxiom (forall v1, v2: $Value :: {$ToEventRep(v1), $ToEventRep(v2)}\n    $IsEqual(v1, v2) &lt;==&gt; $ToEventRep(v1) == $ToEventRep(v2));\n\naxiom (forall v1, v2: Vec $Value :: {$ToGuidRep(v1), $ToGuidRep(v2)}\n    $IsEqual_vec(v1, v2) &lt;==&gt; $ToGuidRep(v1) == $ToGuidRep(v2));\n\n\n{{/if}}\n\n// The well-known field index of the event handle guid.\nconst $EventHandle_$guid: $FieldName;\naxiom $EventHandle_$guid == 1;\n\n// Representation of EventStore that consists of event streams.\ntype {:datatype} $EventStore;\nfunction {:constructor} $EventStore(counter: int, streams: [$GuidRep]Multiset $EventRep): $EventStore;\n\nfunction {:inline} $EventStore__is_well_formed(es: $EventStore): bool {\n    true\n}\n\nfunction {:inline} $EventStore__is_empty(es: $EventStore): bool {\n    (counter#$EventStore(es) == 0) &amp;&amp;\n    (forall guid: $GuidRep ::\n        (var stream := streams#$EventStore(es)[guid];\n        IsEmptyMultiset(stream)))\n}\n\n// This function returns (es1 - es2). This function assumes that es2 is a subset of es1.\nfunction {:inline} $EventStore__subtract(es1: $EventStore, es2: $EventStore): $EventStore {\n    $EventStore(counter#$EventStore(es1)-counter#$EventStore(es2),\n        (lambda guid: $GuidRep ::\n        SubtractMultiset(\n            streams#$EventStore(es1)[guid],\n            streams#$EventStore(es2)[guid])))\n}\n\nfunction {:inline} $EventStore__is_subset(es1: $EventStore, es2: $EventStore): bool {\n    (counter#$EventStore(es1) &lt;= counter#$EventStore(es2)) &amp;&amp;\n    (forall guid: $GuidRep ::\n        IsSubsetMultiset(\n            streams#$EventStore(es1)[guid],\n            streams#$EventStore(es2)[guid]\n        )\n    )\n}\n\nprocedure {:inline 1} $EventStore__diverge(es: $EventStore) returns (es\&#39;: $EventStore) {\n    assume $EventStore__is_subset(es, es\&#39;);\n}\n\nconst $EmptyEventStore: $EventStore;\naxiom $EventStore__is_empty($EmptyEventStore);\n\nfunction {:inline} $ExtendEventStore(es: $EventStore, guid: Vec $Value, msg: $Value): $EventStore {\n    (var stream := streams#$EventStore(es)[$ToGuidRep(guid)];\n    (var stream_new := ExtendMultiset(stream, $ToEventRep(msg));\n    $EventStore(counter#$EventStore(es)+1, streams#$EventStore(es)[$ToGuidRep(guid) := stream_new])))\n}\n\nfunction {:inline} $CondExtendEventStore(es: $EventStore, guid: Vec $Value, msg: $Value, cond: bool): $EventStore {\n    if cond then\n        $ExtendEventStore(es, guid, msg)\n    else\n        es\n}\n\nfunction {:inline} $GetEventHandleGuid(handle: Vec $Value): Vec $Value {\n    $Unbox_vec(ReadVec(handle, $EventHandle_$guid))\n}\n\nvar $es: $EventStore;\n\n// ============================================================================================\n// Abort Handling\n\nvar $abort_flag: bool;\nvar $abort_code: int;\n\nfunction {:inline} $process_abort_code(code: int): int {\n    code\n}\n\nconst $EXEC_FAILURE_CODE: int;\naxiom $EXEC_FAILURE_CODE == -1;\n\n// TODO(wrwg): currently we map aborts of native functions like those for vectors also to\n//   execution failure. This may need to be aligned with what the runtime actually does.\n\nprocedure {:inline 1} $ExecFailureAbort() {\n    $abort_flag := true;\n    $abort_code := $EXEC_FAILURE_CODE;\n}\n\nprocedure {:inline 1} $InitVerification() {\n    // Set abort_flag to false, and havoc abort_code\n    $abort_flag := false;\n    havoc $abort_code;\n    // Assume that the EventStore is initially empty.\n    assume $EventStore__is_empty($es);\n}\n\n// ============================================================================================\n// Instructions\n\nprocedure {:inline 1} $MoveTo(m: $Memory, ta: Vec $TypeValue, a: int, v: Vec $Value) returns (m\&#39;: $Memory)\n{\n    if ($ResourceExists(m, ta, a)) {\n        call $ExecFailureAbort();\n        return;\n    }\n    m\&#39; := $Memory(domain#$Memory(m)[ta, a := true], contents#$Memory(m)[ta, a := v]);\n}\n\nprocedure {:inline 1} $MoveFrom(m: $Memory, a: int, ta: Vec $TypeValue) returns (m\&#39;: $Memory, dst: Vec $Value)\n{\n    if (!$ResourceExists(m, ta, a)) {\n        call $ExecFailureAbort();\n        return;\n    }\n    dst := contents#$Memory(m)[ta, a];\n    m\&#39; := $Memory(domain#$Memory(m)[ta, a := false], contents#$Memory(m)[ta, a := EmptyVec()]);\n}\n\nprocedure {:inline 1} $BorrowGlobal(m: $Memory, a: int, ta: Vec $TypeValue) returns (dst: $Mutation)\n{\n    if (!$ResourceExists(m, ta, a)) {\n        call $ExecFailureAbort();\n        return;\n    }\n    dst := $Mutation($Global(ta, a), $EmptyPath, $Box_vec(contents#$Memory(m)[ta, a]));\n}\n\nprocedure {:inline 1} $BorrowLoc(l: int, v: $Value) returns (dst: $Mutation)\n{\n    dst := $Mutation($Local(l), $EmptyPath, v);\n}\n\nprocedure {:inline 1} $BorrowField(src: $Mutation, f: $FieldName) returns (dst: $Mutation)\n{\n    var p: $Path;\n    var size: int;\n\n    p := p#$Mutation(src);\n    size := size#$Path(p);\n    p := $Path(p#$Path(p)[size := f], size+1);\n    dst := $Mutation(l#$Mutation(src), p, ReadVec($Unbox_vec(v#$Mutation(src)), f));\n}\n\nprocedure {:inline 1} $GetGlobal(m: $Memory, a: int, ta: Vec $TypeValue) returns (dst: Vec $Value)\n{\n    if (!$ResourceExists(m, ta, a)) {\n        call $ExecFailureAbort();\n        return;\n    }\n    dst := $ResourceValue(m, ta, a);\n}\n\nprocedure {:inline 1} $WritebackToGlobalWeak(m: $Memory, src: $Mutation) returns (m\&#39;: $Memory)\n{\n    var l: $Location;\n    var ta: Vec $TypeValue;\n    var a: int;\n    var v: $Value;\n\n    l := l#$Mutation(src);\n    if (is#$Global(l)) {\n        ta := ts#$Global(l);\n        a := a#$Global(l);\n        v := $UpdateValue(p#$Mutation(src), 0, $Box_vec(contents#$Memory(m)[ta, a]), v#$Mutation(src));\n        m\&#39; := $Memory(domain#$Memory(m), contents#$Memory(m)[ta, a := $Unbox_vec(v)]);\n    } else {\n        m\&#39; := m;\n    }\n}\n\nprocedure {:inline 1} $WritebackToValueWeak(src: $Mutation, idx: int, vdst: $Value) returns (vdst\&#39;: $Value)\n{\n    if (l#$Mutation(src) == $Local(idx)) {\n        vdst\&#39; := $UpdateValue(p#$Mutation(src), 0, vdst, v#$Mutation(src));\n    } else {\n        vdst\&#39; := vdst;\n    }\n}\n\nprocedure {:inline 1} $WritebackToValueWeak_int(src: $Mutation, idx: int, vdst: int) returns (vdst\&#39;: int)\n{\n    if (l#$Mutation(src) == $Local(idx)) {\n        vdst\&#39; := $Unbox_int(v#$Mutation(src));\n    } else {\n        vdst\&#39; := vdst;\n    }\n}\n\nprocedure {:inline 1} $WritebackToValueWeak_bool(src: $Mutation, idx: int, vdst: bool) returns (vdst\&#39;: bool)\n{\n    if (l#$Mutation(src) == $Local(idx)) {\n        vdst\&#39; := $Unbox_bool(v#$Mutation(src));\n    } else {\n        vdst\&#39; := vdst;\n    }\n}\n\nprocedure {:inline 1} $WritebackToValueWeak_addr(src: $Mutation, idx: int, vdst: int) returns (vdst\&#39;: int)\n{\n    if (l#$Mutation(src) == $Local(idx)) {\n        vdst\&#39; := $Unbox_addr(v#$Mutation(src));\n    } else {\n        vdst\&#39; := vdst;\n    }\n}\n\nprocedure {:inline 1} $WritebackToValueWeak_vec(src: $Mutation, idx: int, vdst: Vec $Value) returns (vdst\&#39;: Vec $Value)\n{\n    if (l#$Mutation(src) == $Local(idx)) {\n        vdst\&#39; := $Unbox_vec($UpdateValue(p#$Mutation(src), 0, $Box_vec(vdst), v#$Mutation(src)));\n    } else {\n        vdst\&#39; := vdst;\n    }\n}\n\n\nprocedure {:inline 1} $WritebackToReferenceWeak(src: $Mutation, dst: $Mutation) returns (dst\&#39;: $Mutation)\n{\n    var srcPath, dstPath: $Path;\n\n    srcPath := p#$Mutation(src);\n    dstPath := p#$Mutation(dst);\n    if (l#$Mutation(dst) == l#$Mutation(src) &amp;&amp; size#$Path(dstPath) &lt;= size#$Path(srcPath) &amp;&amp; $IsPathPrefix(dstPath, srcPath)) {\n        dst\&#39; := $Mutation(\n                    l#$Mutation(dst),\n                    dstPath,\n                    $UpdateValue(srcPath, size#$Path(dstPath), v#$Mutation(dst), v#$Mutation(src)));\n    } else {\n        dst\&#39; := dst;\n    }\n}\n\nprocedure {:inline 1} $WritebackToGlobalStrong(m: $Memory, src: $Mutation) returns (m\&#39;: $Memory)\n{\n    var l: $Location;\n    var ta: Vec $TypeValue;\n    var a: int;\n    var v: $Value;\n\n    l := l#$Mutation(src);\n    if (is#$Global(l)) {\n        ta := ts#$Global(l);\n        a := a#$Global(l);\n        v := v#$Mutation(src);\n        m\&#39; := $Memory(domain#$Memory(m), contents#$Memory(m)[ta, a := $Unbox_vec(v)]);\n    } else {\n        m\&#39; := m;\n    }\n}\n\nprocedure {:inline 1} $WritebackToValueStrong(src: $Mutation, idx: int, vdst: $Value) returns (vdst\&#39;: $Value)\n{\n    if (l#$Mutation(src) == $Local(idx)) {\n        vdst\&#39; := v#$Mutation(src);\n    } else {\n        vdst\&#39; := vdst;\n    }\n}\n\nprocedure {:inline 1} $WritebackToValueStrong_int(src: $Mutation, idx: int, vdst: int) returns (vdst\&#39;: int)\n{\n    if (l#$Mutation(src) == $Local(idx)) {\n        vdst\&#39; := $Unbox_int(v#$Mutation(src));\n    } else {\n        vdst\&#39; := vdst;\n    }\n}\n\nprocedure {:inline 1} $WritebackToValueStrong_bool(src: $Mutation, idx: int, vdst: bool) returns (vdst\&#39;: bool)\n{\n    if (l#$Mutation(src) == $Local(idx)) {\n        vdst\&#39; := $Unbox_bool(v#$Mutation(src));\n    } else {\n        vdst\&#39; := vdst;\n    }\n}\n\nprocedure {:inline 1} $WritebackToValueStrong_addr(src: $Mutation, idx: int, vdst: int) returns (vdst\&#39;: int)\n{\n    if (l#$Mutation(src) == $Local(idx)) {\n        vdst\&#39; := $Unbox_addr(v#$Mutation(src));\n    } else {\n        vdst\&#39; := vdst;\n    }\n}\n\nprocedure {:inline 1} $WritebackToValueStrong_vec(src: $Mutation, idx: int, vdst: Vec $Value) returns (vdst\&#39;: Vec $Value)\n{\n    if (l#$Mutation(src) == $Local(idx)) {\n        vdst\&#39; := $Unbox_vec(v#$Mutation(src));\n    } else {\n        vdst\&#39; := vdst;\n    }\n}\n\nprocedure {:inline 1} $WritebackToReferenceStrongDirect(src: $Mutation, dst: $Mutation) returns (dst\&#39;: $Mutation)\n{\n    var srcPath, dstPath: $Path;\n\n    srcPath := p#$Mutation(src);\n    dstPath := p#$Mutation(dst);\n    if (l#$Mutation(dst) == l#$Mutation(src) &amp;&amp; size#$Path(dstPath) &lt;= size#$Path(srcPath) &amp;&amp; $IsPathPrefix(dstPath, srcPath)) {\n        dst\&#39; := $Mutation(\n                    l#$Mutation(dst),\n                    dstPath,\n                    v#$Mutation(src));\n    } else {\n        dst\&#39; := dst;\n    }\n}\n\nprocedure {:inline 1} $WritebackToReferenceStrongField(src: $Mutation, dst: $Mutation, edge: $FieldName)\nreturns (dst\&#39;: $Mutation)\n{\n    var srcPath, dstPath: $Path;\n\n    srcPath := p#$Mutation(src);\n    dstPath := p#$Mutation(dst);\n    if (l#$Mutation(dst) == l#$Mutation(src)) {\n        dst\&#39; := $Mutation(\n                    l#$Mutation(dst),\n                    dstPath,\n                    $Box_vec(UpdateVec($Unbox_vec(v#$Mutation(dst)), edge, v#$Mutation(src)))\n                    );\n    } else {\n        dst\&#39; := dst;\n    }\n}\n\n\nprocedure {:inline 1} $WritebackToVec(src: $Mutation, dst: $Mutation)\nreturns (dst\&#39;: $Mutation)\n{\n    var srcPath, dstPath: $Path;\n\n    srcPath := p#$Mutation(src);\n    dstPath := p#$Mutation(dst);\n    if (l#$Mutation(dst) == l#$Mutation(src)) {\n        dst\&#39; := $Mutation(\n                    l#$Mutation(dst),\n                    dstPath,\n                    $Box_vec(UpdateVec($Unbox_vec(v#$Mutation(dst)),\n                    $path_index_at(srcPath, size#$Path(srcPath) - 1), v#$Mutation(src)))\n                    );\n    } else {\n        dst\&#39; := dst;\n    }\n}\n\nprocedure {:inline 1} $Splice1(idx1: int, src1: $Mutation, dst: $Mutation) returns (dst\&#39;: $Mutation) {\n    dst\&#39; := $Mutation(l#$Mutation(src1), $ConcatPath(p#$Mutation(src1), p#$Mutation(dst)), v#$Mutation(dst));\n}\n\nprocedure {:inline 1} $CastU8(src: int) returns (dst: int)\n{\n    if (src &gt; $MAX_U8) {\n        call $ExecFailureAbort();\n        return;\n    }\n    dst := src;\n}\n\nprocedure {:inline 1} $CastU64(src: int) returns (dst: int)\n{\n    if (src &gt; $MAX_U64) {\n        call $ExecFailureAbort();\n        return;\n    }\n    dst := src;\n}\n\nprocedure {:inline 1} $CastU128(src: int) returns (dst: int)\n{\n    if (src &gt; $MAX_U128) {\n        call $ExecFailureAbort();\n        return;\n    }\n    dst := src;\n}\n\nprocedure {:inline 1} $AddU8(src1: int, src2: int) returns (dst: int)\n{\n    if (src1 + src2 &gt; $MAX_U8) {\n        call $ExecFailureAbort();\n        return;\n    }\n    dst := src1 + src2;\n}\n\nprocedure {:inline 1} $AddU64(src1: int, src2: int) returns (dst: int)\n{\n    if (src1 + src2 &gt; $MAX_U64) {\n        call $ExecFailureAbort();\n        return;\n    }\n    dst := src1 + src2;\n}\n\nprocedure {:inline 1} $AddU64_unchecked(src1: int, src2: int) returns (dst: int)\n{\n    dst := src1 + src2;\n}\n\nprocedure {:inline 1} $AddU128(src1: int, src2: int) returns (dst: int)\n{\n    if (src1 + src2 &gt; $MAX_U128) {\n        call $ExecFailureAbort();\n        return;\n    }\n    dst := src1 + src2;\n}\n\nprocedure {:inline 1} $AddU128_unchecked(src1: int, src2: int) returns (dst: int)\n{\n    dst := src1 + src2;\n}\n\nprocedure {:inline 1} $Sub(src1: int, src2: int) returns (dst: int)\n{\n    if (src1 &lt; src2) {\n        call $ExecFailureAbort();\n        return;\n    }\n    dst := src1 - src2;\n}\n\n// Note that *not* inlining the shl/shr functions avoids timeouts. It appears that Z3 can reason\n// better about this if it is an axiomatized function.\nfunction $shl(src1: int, p: int): int {\n    if p == 8 then src1 * 256\n    else if p == 16 then src1 * 65536\n    else if p == 32 then src1 * 4294967296\n    else if p == 64 then src1 * 18446744073709551616\n    // Value is undefined, otherwise.\n    else -1\n}\n\nfunction $shr(src1: int, p: int): int {\n    if p == 8 then src1 div 256\n    else if p == 16 then src1 div 65536\n    else if p == 32 then src1 div 4294967296\n    else if p == 64 then src1 div 18446744073709551616\n    // Value is undefined, otherwise.\n    else -1\n}\n\n// TODO: fix this and $Shr to drop bits on overflow. Requires $Shl8, $Shl64, and $Shl128\nprocedure {:inline 1} $Shl(src1: int, src2: int) returns (dst: int)\n{\n    var res: int;\n    res := $shl(src1, src2);\n    assert res &gt;= 0;   // restriction: shift argument must be 8, 16, 32, or 64\n    dst := res;\n}\n\nprocedure {:inline 1} $Shr(src1: int, src2: int) returns (dst: int)\n{\n    var res: int;\n    res := $shr(src1, src2);\n    assert res &gt;= 0;   // restriction: shift argument must be 8, 16, 32, or 64\n    dst := res;\n}\n\nprocedure {:inline 1} $MulU8(src1: int, src2: int) returns (dst: int)\n{\n    if (src1 * src2 &gt; $MAX_U8) {\n        call $ExecFailureAbort();\n        return;\n    }\n    dst := src1 * src2;\n}\n\nprocedure {:inline 1} $MulU64(src1: int, src2: int) returns (dst: int)\n{\n    if (src1 * src2 &gt; $MAX_U64) {\n        call $ExecFailureAbort();\n        return;\n    }\n    dst := src1 * src2;\n}\n\nprocedure {:inline 1} $MulU128(src1: int, src2: int) returns (dst: int)\n{\n    if (src1 * src2 &gt; $MAX_U128) {\n        call $ExecFailureAbort();\n        return;\n    }\n    dst := src1 * src2;\n}\n\nprocedure {:inline 1} $Div(src1: int, src2: int) returns (dst: int)\n{\n    if (src2 == 0) {\n        call $ExecFailureAbort();\n        return;\n    }\n    dst := src1 div src2;\n}\n\nprocedure {:inline 1} $Mod(src1: int, src2: int) returns (dst: int)\n{\n    if (src2 == 0) {\n        call $ExecFailureAbort();\n        return;\n    }\n    dst := src1 mod src2;\n}\n\nprocedure {:inline 1} $ArithBinaryUnimplemented(src1: int, src2: int) returns (dst: int);\n\nprocedure {:inline 1} $Lt(src1: int, src2: int) returns (dst: bool)\n{\n    dst := src1 &lt; src2;\n}\n\nprocedure {:inline 1} $Gt(src1: int, src2: int) returns (dst: bool)\n{\n    dst := src1 &gt; src2;\n}\n\nprocedure {:inline 1} $Le(src1: int, src2: int) returns (dst: bool)\n{\n    dst := src1 &lt;= src2;\n}\n\nprocedure {:inline 1} $Ge(src1: int, src2: int) returns (dst: bool)\n{\n    dst := src1 &gt;= src2;\n}\n\nprocedure {:inline 1} $And(src1: bool, src2: bool) returns (dst: bool)\n{\n    dst := src1 &amp;&amp; src2;\n}\n\nprocedure {:inline 1} $Or(src1: bool, src2: bool) returns (dst: bool)\n{\n    dst := src1 || src2;\n}\n\nprocedure {:inline 1} $Not(src: bool) returns (dst: bool)\n{\n    dst := !src;\n}\n\n// Pack and Unpack are auto-generated for each type T\n\n\n// ==================================================================================\n// Native Vector Type\n\nfunction {:inline} $Vector_type_value(tv: $TypeValue): $TypeValue {\n    $VectorType(tv)\n}\n\nfunction {:inline} $Vector_$is_well_formed(et: $TypeValue, v: Vec $Value): bool {\n    $TagVec(et, v) &amp;&amp; LenVec(v) &gt;= 0 &amp;&amp; $IsValidU64(LenVec(v))\n}\n\nprocedure {:inline 1} $Vector_empty(ta: $TypeValue) returns (v: Vec $Value) {\n    v := EmptyVec();\n}\n\nfunction {:inline} $Vector_$empty(ta: $TypeValue): Vec $Value {\n    EmptyVec()\n}\n\nprocedure {:inline 1} $Vector_is_empty(ta: $TypeValue, v: Vec $Value) returns (b: bool) {\n    b := LenVec(v) == 0;\n}\n\nprocedure {:inline 1} $Vector_push_back(ta: $TypeValue, m: $Mutation, val: $Value) returns (m\&#39;: $Mutation) {\n    var v: Vec $Value;\n    v := $Unbox_vec($Dereference(m));\n    m\&#39; := $UpdateMutation(m, $Box_vec(ExtendVec(v, val)));\n}\n\nfunction {:inline} $Vector_$push_back(ta: $TypeValue, v: Vec $Value, val: $Value): Vec $Value {\n    ExtendVec(v, val)\n}\n\nprocedure {:inline 1} $Vector_pop_back(ta: $TypeValue, m: $Mutation) returns (e: $Value, m\&#39;: $Mutation) {\n    var v: Vec $Value;\n    var len: int;\n    v := $Unbox_vec($Dereference(m));\n    len := LenVec(v);\n    if (len == 0) {\n        call $ExecFailureAbort();\n        return;\n    }\n    e := ReadVec(v, len-1);\n    m\&#39; := $UpdateMutation(m, $Box_vec(RemoveVec(v)));\n}\n\nprocedure {:inline 1} $Vector_append(ta: $TypeValue, m: $Mutation, other: Vec $Value) returns (m\&#39;: $Mutation) {\n    var v: Vec $Value;\n    v := $Unbox_vec($Dereference(m));\n    m\&#39; := $UpdateMutation(m, $Box_vec(ConcatVec(v, other)));\n}\n\nprocedure {:inline 1} $Vector_reverse(ta: $TypeValue, m: $Mutation) returns (m\&#39;: $Mutation) {\n    var v: Vec $Value;\n    v := $Unbox_vec($Dereference(m));\n    m\&#39; := $UpdateMutation(m, $Box_vec(ReverseVec(v)));\n}\n\nprocedure {:inline 1} $Vector_length(ta: $TypeValue, v: Vec $Value) returns (l: int) {\n    l := LenVec(v);\n}\n\nfunction {:inline} $Vector_$length(ta: $TypeValue, v: Vec $Value): int {\n    LenVec(v)\n}\n\nprocedure {:inline 1} $Vector_borrow(ta: $TypeValue, v: Vec $Value, i: int) returns (dst: $Value) {\n    if (i &lt; 0 || i &gt;= LenVec(v)) {\n        call $ExecFailureAbort();\n        return;\n    }\n    dst := ReadVec(v, i);\n}\n\nfunction {:inline} $Vector_$borrow(ta: $TypeValue, v: Vec $Value, i: int): $Value {\n    ReadVec(v, i)\n}\n\nprocedure {:inline 1} $Vector_borrow_mut(ta: $TypeValue, m: $Mutation, index: int) returns (dst: $Mutation, m\&#39;: $Mutation)\n{\n    var v: Vec $Value;\n    var p: $Path;\n    var size: int;\n\n    v := $Unbox_vec($Dereference(m));\n    if (index &lt; 0 || index &gt;= LenVec(v)) {\n        call $ExecFailureAbort();\n        return;\n    }\n    p := p#$Mutation(m);\n    size := size#$Path(p);\n    p := $Path(p#$Path(p)[size := index], size+1);\n    dst := $Mutation(l#$Mutation(m), p, ReadVec(v, index));\n    m\&#39; := m;\n}\n\nfunction {:inline} $Vector_$borrow_mut(ta: $TypeValue, v: Vec $Value, i: int): $Value {\n    ReadVec(v, i)\n}\n\nprocedure {:inline 1} $Vector_destroy_empty(ta: $TypeValue, v: Vec $Value) {\n    if (!IsEmptyVec(v)) {\n      call $ExecFailureAbort();\n    }\n}\n\nprocedure {:inline 1} $Vector_swap(ta: $TypeValue, m: $Mutation, i: int, j: int) returns (m\&#39;: $Mutation)\n{\n    var v: Vec $Value;\n    v := $Unbox_vec($Dereference(m));\n    if (i &gt;= LenVec(v) || j &gt;= LenVec(v) || i &lt; 0 || j &lt; 0) {\n        call $ExecFailureAbort();\n        return;\n    }\n    m\&#39; := $UpdateMutation(m, $Box_vec(SwapVec(v, i, j)));\n}\n\nfunction {:inline} $Vector_$swap(ta: $TypeValue, v: Vec $Value, i: int, j: int): Vec $Value {\n    SwapVec(v, i, j)\n}\n\nprocedure {:inline 1} $Vector_remove(ta: $TypeValue, m: $Mutation, i: int) returns (e: $Value, m\&#39;: $Mutation)\n{\n    var v: Vec $Value;\n\n    v := $Unbox_vec($Dereference(m));\n\n    if (i &lt; 0 || i &gt;= LenVec(v)) {\n        call $ExecFailureAbort();\n        return;\n    }\n    e := ReadVec(v, i);\n    m\&#39; := $UpdateMutation(m, $Box_vec(RemoveAtVec(v, i)));\n}\n\nprocedure {:inline 1} $Vector_swap_remove(ta: $TypeValue, m: $Mutation, i: int) returns (e: $Value, m\&#39;: $Mutation)\n{\n    var len: int;\n    var v: Vec $Value;\n\n    v := $Unbox_vec($Dereference(m));\n\n    len := LenVec(v);\n    if (i &lt; 0 || i &gt;= len) {\n        call $ExecFailureAbort();\n        return;\n    }\n    e := ReadVec(v, i);\n    m\&#39; := $UpdateMutation(m, $Box_vec(RemoveVec(SwapVec(v, i, len-1))));\n}\n\nprocedure {:inline 1} $Vector_contains(ta: $TypeValue, v: Vec $Value, e: $Value) returns (res: bool)  {\n    res := $ContainsVec(v, e);\n}\n\n/*\nprocedure {:inline 1}\n$Vector_index_of(ta: $TypeValue, v: Vec $Value, e: $Value) returns (res1: bool, res2: int) {\n    res2 := $IndexOfVec(v, e);\n    if (res2 &gt;= 0) {\n        res1 := true;\n    } else {\n        res1 := false;\n        res2 := 0;\n    }\n}\n*/\n\n// FIXME: This procedure sometimes (not always) make the test (performance_200511) very slow (&gt; 10 mins) or hang\n// although this is not used in the test script (performance_200511). The test finishes in 20 secs when it works fine.\nprocedure {:inline 1} $Vector_index_of(ta: $TypeValue, v: Vec $Value, e: $Value) returns (res1: bool, res2: int);\nensures 0 &lt;= res2 &amp;&amp; res2 &lt; LenVec(v);\nensures res1 == $ContainsVec(v, e);\nensures res1 ==&gt; $IsEqual(ReadVec(v, res2), e);\nensures res1 ==&gt; (forall i:int :: 0 &lt;= i &amp;&amp; i &lt; res2 ==&gt; !$IsEqual(ReadVec(v, i), e));\nensures !res1 ==&gt; res2 == 0;\n\n\n// ==================================================================================\n// Native hash\n\n// Hash is modeled as an otherwise uninterpreted injection.\n// In truth, it is not an injection since the domain has greater cardinality\n// (arbitrary length vectors) than the co-domain (vectors of length 32).  But it is\n// common to assume in code there are no hash collisions in practice.  Fortunately,\n// Boogie is not smart enough to recognized that there is an inconsistency.\n// FIXME: If we were using a reliable extensional theory of arrays, and if we could use ==\n// instead of $IsEqual, we might be able to avoid so many quantified formulas by\n// using a sha2_inverse function in the ensures conditions of Hash_sha2_256 to\n// assert that sha2/3 are injections without using global quantified axioms.\n\n\nfunction {:inline} $Hash_sha2(val: Vec $Value): Vec $Value {\n    $Hash_sha2_core(val)\n}\n\nfunction $Hash_sha2_core(val: Vec $Value): Vec $Value;\n\n// This says that Hash_sha2 is bijective.\naxiom (forall v1,v2: Vec $Value :: {$Hash_sha2_core(v1), $Hash_sha2_core(v2)}\n       $IsEqual_vec(v1, v2) &lt;==&gt; $IsEqual_vec($Hash_sha2_core(v1), $Hash_sha2_core(v2)));\n\n// This procedure has no body. We want Boogie to just use its requires\n// and ensures properties when verifying code that calls it.\nprocedure $Hash_sha2_256(val: Vec $Value) returns (res: Vec $Value);\n// It will still work without this, but this helps verifier find more reasonable counterexamples.\n{{options.type_requires}} $IsValidU8Vector(val);\nensures res == $Hash_sha2_core(val);     // returns Hash_sha2 Value\nensures $IsValidU8Vector(res);    // result is a legal vector of U8s.\nensures LenVec(res) == 32;               // result is 32 bytes.\n\n// Spec version of Move native function.\nfunction {:inline} $Hash_$sha2_256(val: Vec $Value): Vec $Value {\n    $Hash_sha2_core(val)\n}\n\n// similarly for Hash_sha3\nfunction {:inline} $Hash_sha3(val: Vec $Value): Vec $Value {\n    $Hash_sha3_core(val)\n}\nfunction $Hash_sha3_core(val: Vec $Value): Vec $Value;\n\naxiom (forall v1,v2: Vec $Value :: {$Hash_sha3_core(v1), $Hash_sha3_core(v2)}\n       $IsEqual_vec(v1, v2) &lt;==&gt; $IsEqual_vec($Hash_sha3_core(v1), $Hash_sha3_core(v2)));\n\nprocedure $Hash_sha3_256(val: Vec $Value) returns (res: Vec $Value);\nensures res == $Hash_sha3_core(val);     // returns Hash_sha3 Value\nensures $IsValidU8Vector(res);    // result is a legal vector of U8s.\nensures LenVec(res) == 32;               // result is 32 bytes.\n\n// Spec version of Move native function.\nfunction {:inline} $Hash_$sha3_256(val: Vec $Value): Vec $Value {\n    $Hash_sha3_core(val)\n}\n\n// ==================================================================================\n// Native diem_account\n\nprocedure {:inline 1} $DiemAccount_create_signer(\n  addr: int\n) returns (signer: int) {\n    // A signer is currently identical to an address.\n    signer := addr;\n}\n\nprocedure {:inline 1} $DiemAccount_destroy_signer(\n  signer: int\n) {\n  return;\n}\n\n// ==================================================================================\n// Native Signer\n\nprocedure {:inline 1} $Signer_borrow_address(signer: int) returns (res: int) {\n    res := signer;\n}\n\n// ==================================================================================\n// Native signature\n\n// Signature related functionality is handled via uninterpreted functions. This is sound\n// currently because we verify every code path based on signature verification with\n// an arbitrary interpretation.\n\nfunction $Signature_$ed25519_validate_pubkey(public_key: Vec $Value): bool;\nfunction $Signature_$ed25519_verify(signature: Vec $Value, public_key: Vec $Value, message: Vec $Value): bool;\n\n// Needed because we do not have extensional equality:\naxiom (forall k1, k2: Vec $Value ::\n    {$Signature_$ed25519_validate_pubkey(k1), $Signature_$ed25519_validate_pubkey(k2)}\n    $IsEqual_vec(k1, k2) ==&gt; $Signature_$ed25519_validate_pubkey(k1) == $Signature_$ed25519_validate_pubkey(k2));\naxiom (forall s1, s2, k1, k2, m1, m2: Vec $Value ::\n    {$Signature_$ed25519_verify(s1, k1, m1), $Signature_$ed25519_verify(s2, k2, m2)}\n    $IsEqual_vec(s1, s2) &amp;&amp; $IsEqual_vec(k1, k2) &amp;&amp; $IsEqual_vec(m1, m2)\n    ==&gt; $Signature_$ed25519_verify(s1, k1, m1) == $Signature_$ed25519_verify(s2, k2, m2));\n\n\nprocedure {:inline 1} $Signature_ed25519_validate_pubkey(public_key: Vec $Value) returns (res: bool) {\n    res := $Signature_$ed25519_validate_pubkey(public_key);\n}\n\nprocedure {:inline 1} $Signature_ed25519_verify(\n        signature: Vec $Value, public_key: Vec $Value, message: Vec $Value) returns (res: bool) {\n    res := $Signature_$ed25519_verify(signature, public_key, message);\n}\n\n// ==================================================================================\n// Native BCS::serialize\n\n// native define serialize&lt;MoveValue&gt;(v: &amp;MoveValue): vector&lt;u8&gt;;\n\n// Serialize is modeled as an uninterpreted function, with an additional\n// axiom to say it\&#39;s an injection.\n\nfunction {:inline} $BCS_serialize(ta: $TypeValue, v: $Value): Vec $Value {\n    $BCS_serialize_core(v)\n}\n\nfunction $BCS_serialize_core(v: $Value): Vec $Value;\naxiom (forall v1, v2: $Value :: {$BCS_serialize_core(v1), $BCS_serialize_core(v2)}\n   $IsEqual(v1, v2) &lt;==&gt; $IsEqual_vec($BCS_serialize_core(v1), $BCS_serialize_core(v2)));\n\n// This says that serialize returns a non-empty vec&lt;u8&gt;\n{{#if (eq options.serialize_bound 0)}}\naxiom (forall v: $Value :: {$BCS_serialize_core(v)}\n     ( var r := $BCS_serialize_core(v); $IsValidU8Vector(r) &amp;&amp; LenVec(r) &gt; 0 ));\n{{else}}\naxiom (forall v: $Value :: {$BCS_serialize_core(v)}\n     ( var r := $BCS_serialize_core(v); $IsValidU8Vector(r) &amp;&amp; LenVec(r) &gt; 0 &amp;&amp;\n                            LenVec(r) &lt;= {{options.serialize_bound}} ));\n{{/if}}\n\n// Serialized addresses should have the same length\nconst $serialized_address_len: int;\naxiom (forall v: $Value :: {$BCS_serialize_core(v)}\n     ( var r := $BCS_serialize_core(v); is#$Address(v) ==&gt; LenVec(r) == $serialized_address_len));\n\nprocedure $BCS_to_bytes(ta: $TypeValue, v: $Value) returns (res: Vec $Value);\nensures res == $BCS_serialize_core(v);\n\nfunction {:inline} $BCS_$to_bytes(ta: $TypeValue, v: $Value): Vec $Value {\n    $BCS_serialize_core(v)\n}\n\n// ==================================================================================\n// Native Signer::spec_address_of\n\nfunction {:inline} $Signer_spec_address_of(signer: int): int\n{\n    // A signer is currently identical to an address.\n    signer\n}\n\nfunction {:inline} $Signer_$borrow_address(signer: int): int\n{\n    // A signer is currently identical to an address.\n    signer\n}\n\n// ==================================================================================\n// Mocked out Event module\n\nprocedure {:inline 1} $Event_new_event_handle(t: $TypeValue, signer: int) returns (res: Vec $Value) {\n}\n\nprocedure {:inline 1} $Event_publish_generator(account: int) {\n}\n\n// This boogie procedure is the model of `emit_event`. This model abstracts away the `counter` behavior, thus not\n// mutating (or increasing) `counter`.\n\nprocedure {:inline 1} $Event_emit_event(t: $TypeValue, handler: $Mutation, msg: $Value) returns (res: $Mutation) {\n    var guid: Vec $Value;\n    guid := $GetEventHandleGuid($Unbox_vec($Dereference(handler)));\n    $es := $ExtendEventStore($es, guid, msg);\n    res := handler;\n}\n\nprocedure {:inline 1} $Event_write_to_event_store(t: $TypeValue, guid: Vec $Value, count: int, msg: $Value) {\n    // This function should never be called as it is private to Event but the caller, emit_event, is mocked out.\n    assert false;\n}\n\nprocedure {:inline 1} $Event_destroy_handle(t: $TypeValue, handle: Vec $Value) {\n}\n&quot;;</pre></section><section id="search" class="content hidden"></section><section class="footer"></section><div id="rustdoc-vars" data-root-path="../" data-current-crate="boogie_backend"></div>
    <script src="../main.js"></script><script defer src="../search-index.js"></script></body></html>